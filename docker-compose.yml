version: '3.8'

services:
  app:
    build: .
    container_name: neuromemory_app
    # 兼容策略 1: 本地开发时，我们可能想挂载代码进去实时修改，不用每次改代码都重新 build
    # 在 ZeaBur 上这一行会被忽略或无害
    volumes:
      - .:/app
    environment:
      # 兼容策略 2: 让代码知道数据库在哪里
      # 在 Docker 内部互联，必须用服务名 'neo4j'，不能用 localhost
      - NEO4J_URI=bolt://neo4j:7687
      - QDRANT_HOST=qdrant
      - QDRANT_PORT=6333
      # --- 1. 引用 Zeabur 注入的变量 (不需要赋值，只写 Key) ---
      - DeepSeekApiKey
      - SiliconFlowApiKey
      # 告诉 Python 代码：密码是多少
      # 语法含义：如果在 Zeabur 读到了 NEO4J_PASSWORD 变量，就用它；
      #          如果没有（比如在本地），就默认用 'password123'。
      - NEO4J_PASSWORD=${NEO4J_PASSWORD:-password123}

      # --- 2. 架构硬编码 (替代了那些 service-xxx 变量) ---
      # 告诉 Python 代码：Neo4j 就在隔壁，名字叫 neo4j
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USERNAME=neo4j
      # 告诉 Python 代码：Qdrant 就在隔壁，名字叫 qdrant
      - QDRANT_HOST=qdrant
      - QDRANT_PORT=6333

      # 其他变量建议通过 .env 文件管理，不要写死在这里

    depends_on:
      - neo4j
      - qdrant
    ports:
      - "8765:8765"

  neo4j:
    image: neo4j:5.26.0
    container_name: memory_graph_db
    ports:
      # 兼容策略 3: 保留你的本地偏好端口
      # 格式是 "宿主机端口:容器端口"
      # 本地访问用 17687，ZeaBur 内部互联依然认 7687，互不干扰
      - "17687:7687" 
      - "7474:7474"
    environment:
      - NEO4J_AUTH=neo4j/password123
      - NEO4J_PLUGINS=["apoc", "graph-data-science"]
      - NEO4J_dbms_security_procedures_unrestricted=apoc.*,gds.*
    volumes:
      - neo4j_data:/data
    # ... healthcheck ...

  qdrant:
    image: qdrant/qdrant:latest
    container_name: memory_vector_db
    ports:
      # 兼容策略 4: 同理，本地用 6400，容器内部依然是 6333
      - "6400:6333"
    volumes:
      - qdrant_data:/qdrant/storage

volumes:
  neo4j_data:
  qdrant_data:
